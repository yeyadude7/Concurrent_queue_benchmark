# Multicore Queue Evaluation

Goal:
Evaluate the performance and scalability of lock-based, lock-free, and batching message queues in multicore, server-side producer–consumer architectures.
The framework benchmarks four queue designs—LockBasedQueue, MSQueue, BatchQueue, and BackoffBatchQueue—across varying thread counts and request loads, measuring runtime, throughput, and latency.

---

Project Structure

src/
  core/               # Queue interface, benchmark runner, metrics
  queue/              # Queue implementations (LockBased, MSQueue, BatchQueue, BackoffBatchQueue)
  simulation/         # Producer/consumer threads and workload model
  results/            # Auto-generated benchmark outputs

  analysis/
    analyze_results.py  # Aggregates results and produces plots
  final_analysis_output/ # Generated CSVs and visualizations

bin/                  # Compiled bytecode

---

Build and Run

Compile
javac -d bin $(find src -name "*.java")

Run full benchmark suite
java -Xms2G -Xmx4G -cp bin core.AutoBenchmarkRunner

Benchmark results are written to:
src/results/threads_{THREADS}_{REQS}_reqPerClient/
Each directory contains four result files—one for each queue design.

---

Run Analysis

cd analysis
python analyze_results.py

This produces aggregated CSV files and plots under:
final_analysis_output/

---

Summary

This project provides a controlled environment for comparing contention behavior in several shared-memory queue algorithms.
The benchmark and analysis pipeline can be extended to additional queue designs, workloads, or multicore architectures.

